use std::borrow::Cow;
use std::cell::RefCell;
use std::collections::HashMap;

use crate::bind_groups::{
    BindGroupLayoutDescriptor, BindGroupLayoutEntry, BindGroupLayoutResource, StorageTextureAccess,
    StorageTextureBindingLayout, TextureBindingLayout,
};
use crate::pipeline::layout::{PipelineLayoutDescriptor, PipelineLayoutKind};
use crate::pipeline::{ComputePipelineDescriptor, ProgrammableStage};
use crate::shaders::ShaderModuleExt;

use crate::error::Result;
use crate::texture::{TextureFormat, TextureSampleType};
use crate::{
    bind_groups::{BindGroupDescriptor, BindGroupEntry, BindGroupResource},
    command::compute_pass::ComputePassDescriptor,
    error::AwsmCoreError,
    renderer::AwsmRendererWebGpu,
    shaders::ShaderModuleDescriptor,
    texture::{TextureViewDescriptor, TextureViewDimension},
};

#[derive(Debug, Clone)]
struct MipmapPipeline {
    pub compute_pipeline: web_sys::GpuComputePipeline,
    pub bind_group_layout: web_sys::GpuBindGroupLayout,
}

thread_local! {
    static MIPMAP_PIPELINE: RefCell<HashMap<LookupKey, MipmapPipeline>> = RefCell::new(HashMap::new());
}

#[derive(Hash, Debug, Eq, PartialEq)]
struct LookupKey {
    pub texture_format: String,
    pub is_array: bool,
}

fn storage_format_to_wgsl(format: TextureFormat) -> Result<&'static str> {
    match format {
        TextureFormat::Rgba8unorm => Ok("rgba8unorm"),
        TextureFormat::Rgba16float => Ok("rgba16float"),
        TextureFormat::Rgba32float => Ok("rgba32float"),
        _ => Err(AwsmCoreError::MipmapUnsupportedFormat(format)),
    }
}

// Tile-aware mipmap generation with texture-type-specific filtering
// Based on per-tile processing to prevent bleeding between atlas textures
fn tile_aware_mipmap_shader_source(format: TextureFormat, is_array: bool) -> Result<String> {
    let storage_format = storage_format_to_wgsl(format)?;

    let texture_type = if is_array {
        "texture_2d_array<f32>"
    } else {
        "texture_2d<f32>"
    };

    let storage_type = if is_array {
        format!("texture_storage_2d_array<{storage_format}, write>")
    } else {
        format!("texture_storage_2d<{storage_format}, write>")
    };

    let layer_param = if is_array { ", layer: i32" } else { "" };
    let layer_arg = if is_array { ", layer" } else { "" };
    let layer_field = if is_array { "layer: i32," } else { "" };

    Ok(format!(
        r#"
@group(0) @binding(0) var src: {texture_type};
@group(0) @binding(1) var dst: {storage_type};

struct Rect {{
    min: vec2<i32>,
    max: vec2<i32>,
}};

struct Params {{
    srcInteriorMin: vec2<i32>,
    srcInteriorMax: vec2<i32>,
    gutter: i32,
    textureType: u32,  // 0=Albedo, 1=Normal, 2=MetallicRoughness, 3=Occlusion, 4=Emissive
    {layer_field}
}};

@group(0) @binding(2) var<uniform> params: Params;

const TEXTURE_TYPE_ALBEDO: u32 = 0u;
const TEXTURE_TYPE_NORMAL: u32 = 1u;
const TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 2u;
const TEXTURE_TYPE_OCCLUSION: u32 = 3u;
const TEXTURE_TYPE_EMISSIVE: u32 = 4u;

fn clamp_to_rect(p: vec2<i32>, r: Rect) -> vec2<i32> {{
    return clamp(p, r.min, r.max - vec2<i32>(1));
}}

fn load_texel(coord: vec2<i32>{layer_param}) -> vec4<f32> {{
    return textureLoad(src, coord{layer_arg}, 0);
}}

fn store_texel(coord: vec2<i32>{layer_param}, color: vec4<f32>) {{
    textureStore(dst, coord{layer_arg}, color);
}}

// Unpremultiply alpha for correct filtering
fn unpremultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    if (color.a > 0.0001) {{
        return vec4<f32>(color.rgb / color.a, color.a);
    }}
    return color;
}}

// Premultiply alpha after filtering
fn premultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    return vec4<f32>(color.rgb * color.a, color.a);
}}

// Standard 2x2 box filter
fn filter_albedo(samples: array<vec4<f32>, 4>) -> vec4<f32> {{
    // Unpremultiply, average, then premultiply for correct alpha blending
    var sum = vec4<f32>(0.0);
    for (var i = 0; i < 4; i++) {{
        sum += unpremultiply_alpha(samples[i]);
    }}
    return premultiply_alpha(sum * 0.25);
}}

// Normal map filtering: average then renormalize
fn filter_normal(samples: array<vec4<f32>, 4>) -> vec4<f32> {{
    var sum = vec4<f32>(0.0);
    for (var i = 0; i < 4; i++) {{
        sum += samples[i];
    }}
    let avg = sum * 0.25;

    // Renormalize the normal vector (stored in RGB)
    let normal_xyz = avg.xyz * 2.0 - 1.0;  // Convert from [0,1] to [-1,1]
    let normalized = normalize(normal_xyz);
    let renormalized = normalized * 0.5 + 0.5;  // Convert back to [0,1]

    return vec4<f32>(renormalized, avg.a);
}}

// Metallic/Roughness: roughness in G channel needs perceptual averaging (r²)
fn filter_metallic_roughness(samples: array<vec4<f32>, 4>) -> vec4<f32> {{
    var metallic_sum = 0.0;
    var roughness_squared_sum = 0.0;
    var b_sum = 0.0;
    var alpha_sum = 0.0;

    for (var i = 0; i < 4; i++) {{
        metallic_sum += samples[i].r;  // Metallic (linear average)
        let roughness = samples[i].g;
        roughness_squared_sum += roughness * roughness;  // Perceptual averaging
        b_sum += samples[i].b;
        alpha_sum += samples[i].a;
    }}

    return vec4<f32>(
        metallic_sum * 0.25,
        sqrt(roughness_squared_sum * 0.25),  // Take sqrt after averaging r²
        b_sum * 0.25,
        alpha_sum * 0.25
    );
}}

// Occlusion and Emissive: standard averaging
fn filter_standard(samples: array<vec4<f32>, 4>) -> vec4<f32> {{
    var sum = vec4<f32>(0.0);
    for (var i = 0; i < 4; i++) {{
        sum += samples[i];
    }}
    return sum * 0.25;
}}

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {{
    // Compute child interior and padded rect
    let childInteriorMin = params.srcInteriorMin / 2;
    let childInteriorMax = (params.srcInteriorMax + vec2<i32>(1, 1)) / 2;
    let g = vec2<i32>(params.gutter, params.gutter);
    let dstRectMin = childInteriorMin - g;
    let dstRectMax = childInteriorMax + g;

    let d = vec2<i32>(gid.xy) + dstRectMin;
    if (any(d < dstRectMin) || any(d >= dstRectMax)) {{
        return;
    }}

    // Clamp destination to interior for gutter filling (edge extension)
    let d_clamped = clamp(d, childInteriorMin, childInteriorMax - vec2<i32>(1));

    // Map to parent texels (2x2 region)
    let s_base = 2 * d_clamped;
    let srcRect = Rect(params.srcInteriorMin, params.srcInteriorMax);

    let s00 = clamp_to_rect(s_base + vec2<i32>(0, 0), srcRect);
    let s10 = clamp_to_rect(s_base + vec2<i32>(1, 0), srcRect);
    let s01 = clamp_to_rect(s_base + vec2<i32>(0, 1), srcRect);
    let s11 = clamp_to_rect(s_base + vec2<i32>(1, 1), srcRect);

    // Load all 4 samples
    var samples: array<vec4<f32>, 4>;
    samples[0] = load_texel(s00{layer_arg});
    samples[1] = load_texel(s10{layer_arg});
    samples[2] = load_texel(s01{layer_arg});
    samples[3] = load_texel(s11{layer_arg});

    // Apply appropriate filtering based on texture type
    var result: vec4<f32>;
    switch (params.textureType) {{
        case TEXTURE_TYPE_NORMAL: {{
            result = filter_normal(samples);
        }}
        case TEXTURE_TYPE_METALLIC_ROUGHNESS: {{
            result = filter_metallic_roughness(samples);
        }}
        case TEXTURE_TYPE_OCCLUSION, TEXTURE_TYPE_EMISSIVE: {{
            result = filter_standard(samples);
        }}
        default: {{  // TEXTURE_TYPE_ALBEDO
            result = filter_albedo(samples);
        }}
    }}

    store_texel(d{layer_arg}, result);
}}
"#
    ))
}

// Edge detection using Sobel operator
fn edge_detection_shader_source(format: TextureFormat, is_array: bool) -> Result<String> {
    let storage_format = storage_format_to_wgsl(format)?;

    if is_array {
        Ok(format!(
            r#"
@group(0) @binding(0) var input_texture: texture_2d_array<f32>;
@group(0) @binding(1) var edge_map: texture_storage_2d_array<{storage_format}, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {{
    let dims = textureDimensions(input_texture);
    if (global_id.x >= dims.x || global_id.y >= dims.y) {{
        return;
    }}

    let layer = i32(global_id.z);
    let coord = vec2<i32>(global_id.xy);

    // Sobel operator kernels
    // Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]
    // Gy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]

    var gx = vec3<f32>(0.0);
    var gy = vec3<f32>(0.0);

    // Sample 3x3 neighborhood
    for (var dy = -1; dy <= 1; dy++) {{
        for (var dx = -1; dx <= 1; dx++) {{
            let sample_coord = clamp(
                coord + vec2<i32>(dx, dy),
                vec2<i32>(0),
                vec2<i32>(dims) - vec2<i32>(1)
            );
            let sample = textureLoad(input_texture, sample_coord, layer, 0).rgb;

            // Apply Sobel kernels
            let gx_weight = f32(dx) * (2.0 - abs(f32(dy)));
            let gy_weight = f32(dy) * (2.0 - abs(f32(dx)));

            gx += sample * gx_weight;
            gy += sample * gy_weight;
        }}
    }}

    // Calculate edge magnitude
    // Don't over-normalize - keep edges strong for thin line detection
    let edge_strength = sqrt(dot(gx, gx) + dot(gy, gy)) / 4.0; // Less aggressive normalization

    // Store edge strength in all channels (we'll use red channel in mipmap generation)
    let edge_output = vec4<f32>(edge_strength, edge_strength, edge_strength, 1.0);
    textureStore(edge_map, coord, layer, edge_output);
}}
"#
        ))
    } else {
        Ok(format!(
            r#"
@group(0) @binding(0) var input_texture: texture_2d<f32>;
@group(0) @binding(1) var edge_map: texture_storage_2d<{storage_format}, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {{
    let dims = textureDimensions(input_texture, 0);
    if (global_id.x >= dims.x || global_id.y >= dims.y) {{
        return;
    }}

    let coord = vec2<i32>(global_id.xy);

    // Sobel operator kernels
    var gx = vec3<f32>(0.0);
    var gy = vec3<f32>(0.0);

    // Sample 3x3 neighborhood
    for (var dy = -1; dy <= 1; dy++) {{
        for (var dx = -1; dx <= 1; dx++) {{
            let sample_coord = clamp(
                coord + vec2<i32>(dx, dy),
                vec2<i32>(0),
                vec2<i32>(dims) - vec2<i32>(1)
            );
            let sample = textureLoad(input_texture, sample_coord, 0).rgb;

            // Apply Sobel kernels
            let gx_weight = f32(dx) * (2.0 - abs(f32(dy)));
            let gy_weight = f32(dy) * (2.0 - abs(f32(dx)));

            gx += sample * gx_weight;
            gy += sample * gy_weight;
        }}
    }}

    // Calculate edge magnitude
    // Don't over-normalize - keep edges strong for thin line detection
    let edge_strength = sqrt(dot(gx, gx) + dot(gy, gy)) / 4.0; // Less aggressive normalization

    // Store edge strength in all channels
    let edge_output = vec4<f32>(edge_strength, edge_strength, edge_strength, 1.0);
    textureStore(edge_map, coord, edge_output);
}}
"#
        ))
    }
}

// High-quality mipmap generation with Kaiser filter and edge awareness
fn mipmap_shader_source(format: TextureFormat, is_array: bool) -> Result<String> {
    let storage_format = storage_format_to_wgsl(format)?;

    if is_array {
        Ok(format!(
            r#"
@group(0) @binding(0) var input_texture: texture_2d_array<f32>;
@group(0) @binding(1) var edge_map: texture_2d_array<f32>;
@group(0) @binding(2) var output_texture: texture_storage_2d_array<{storage_format}, write>;

// Kaiser-Bessel filter weights (β=3.0, 8-tap kernel)
// Precomputed for performance: I₀(β√(1-r²))/I₀(β) where r is normalized radius
const KAISER_WEIGHTS = array<f32, 9>(
    1.0000,  // center (r=0)
    0.9036,  // r=0.353 (diagonal to adjacent)
    0.7854,  // r=0.5 (adjacent)
    0.6548,  // r=0.612 (diagonal)
    0.5000,  // r=0.707 (corner)
    0.3452,  // r=0.791
    0.2146,  // r=0.866
    0.0964,  // r=0.935
    0.0000   // r=1.0
);

fn kaiser_weight(dx: f32, dy: f32) -> f32 {{
    let r = sqrt(dx * dx + dy * dy) / 2.0; // Normalize by kernel radius
    if (r >= 1.0) {{ return 0.0; }}

    // Linear interpolation in lookup table
    let idx = r * 8.0;
    let i0 = u32(floor(idx));
    let i1 = min(i0 + 1u, 8u);
    let frac = fract(idx);

    return mix(KAISER_WEIGHTS[i0], KAISER_WEIGHTS[i1], frac);
}}

fn unpremultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    if (color.a <= 0.001) {{
        return vec4<f32>(0.0, 0.0, 0.0, 0.0);
    }}
    return vec4<f32>(color.rgb / color.a, color.a);
}}

fn premultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    return vec4<f32>(color.rgb * color.a, color.a);
}}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {{
    let output_size = textureDimensions(output_texture);

    if (global_id.x >= output_size.x || global_id.y >= output_size.y) {{
        return;
    }}

    let layer = i32(global_id.z);
    let input_size = textureDimensions(input_texture);
    let output_coord = vec2<i32>(global_id.xy);

    // Center of the 2x2 region in input space
    let input_center = vec2<f32>(output_coord) * 2.0 + 1.0;

    // 8-tap Kaiser filter sampling pattern
    // Sample in a 4x4 region centered on the 2x2 block
    var accumulated_color = vec4<f32>(0.0);
    var total_weight = 0.0;
    var max_edge_strength = 0.0;

    // Sample 4x4 region with Kaiser weighting
    for (var dy = -1; dy <= 2; dy++) {{
        for (var dx = -1; dx <= 2; dx++) {{
            let sample_coord = vec2<i32>(input_center) + vec2<i32>(dx, dy);
            let clamped_coord = clamp(
                sample_coord,
                vec2<i32>(0),
                vec2<i32>(input_size) - vec2<i32>(1)
            );

            // Load color and edge strength
            let color = textureLoad(input_texture, clamped_coord, layer, 0);
            let edge_strength = textureLoad(edge_map, clamped_coord, layer, 0).r;

            max_edge_strength = max(max_edge_strength, edge_strength);

            // Calculate Kaiser weight based on distance from center
            let offset = vec2<f32>(sample_coord) - input_center;
            let weight = kaiser_weight(offset.x, offset.y);

            // Un-premultiply alpha for correct filtering
            let unpremul = unpremultiply_alpha(color);

            accumulated_color += unpremul * weight;
            total_weight += weight;
        }}
    }}

    // Normalize by total weight
    var result = accumulated_color / max(total_weight, 0.0001);

    // Use standard Kaiser filtering - no edge preservation
    // This properly blurs thin lines at higher mip levels like hardware mipmaps
    textureStore(output_texture, output_coord, layer, result);
}}
"#
        ))
    } else {
        Ok(format!(
            r#"
@group(0) @binding(0) var input_texture: texture_2d<f32>;
@group(0) @binding(1) var edge_map: texture_2d<f32>;
@group(0) @binding(2) var output_texture: texture_storage_2d<{storage_format}, write>;

// Kaiser-Bessel filter weights (β=3.0, 8-tap kernel)
const KAISER_WEIGHTS = array<f32, 9>(
    1.0000,  // center (r=0)
    0.9036,  // r=0.353
    0.7854,  // r=0.5
    0.6548,  // r=0.612
    0.5000,  // r=0.707
    0.3452,  // r=0.791
    0.2146,  // r=0.866
    0.0964,  // r=0.935
    0.0000   // r=1.0
);

fn kaiser_weight(dx: f32, dy: f32) -> f32 {{
    let r = sqrt(dx * dx + dy * dy) / 2.0;
    if (r >= 1.0) {{ return 0.0; }}

    let idx = r * 8.0;
    let i0 = u32(floor(idx));
    let i1 = min(i0 + 1u, 8u);
    let frac = fract(idx);

    return mix(KAISER_WEIGHTS[i0], KAISER_WEIGHTS[i1], frac);
}}

fn unpremultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    if (color.a <= 0.001) {{
        return vec4<f32>(0.0, 0.0, 0.0, 0.0);
    }}
    return vec4<f32>(color.rgb / color.a, color.a);
}}

fn premultiply_alpha(color: vec4<f32>) -> vec4<f32> {{
    return vec4<f32>(color.rgb * color.a, color.a);
}}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {{
    let output_size = textureDimensions(output_texture);

    if (global_id.x >= output_size.x || global_id.y >= output_size.y) {{
        return;
    }}

    let input_size = textureDimensions(input_texture, 0);
    let output_coord = vec2<i32>(global_id.xy);

    let input_center = vec2<f32>(output_coord) * 2.0 + 1.0;

    var accumulated_color = vec4<f32>(0.0);
    var total_weight = 0.0;
    var max_edge_strength = 0.0;

    // 4x4 Kaiser sampling
    for (var dy = -1; dy <= 2; dy++) {{
        for (var dx = -1; dx <= 2; dx++) {{
            let sample_coord = vec2<i32>(input_center) + vec2<i32>(dx, dy);
            let clamped_coord = clamp(
                sample_coord,
                vec2<i32>(0),
                vec2<i32>(input_size) - vec2<i32>(1)
            );

            let color = textureLoad(input_texture, clamped_coord, 0);
            let edge_strength = textureLoad(edge_map, clamped_coord, 0).r;

            max_edge_strength = max(max_edge_strength, edge_strength);

            let offset = vec2<f32>(sample_coord) - input_center;
            let weight = kaiser_weight(offset.x, offset.y);

            let unpremul = unpremultiply_alpha(color);

            accumulated_color += unpremul * weight;
            total_weight += weight;
        }}
    }}

    var kaiser_result = accumulated_color / max(total_weight, 0.0001);

    // ULTRA-AGGRESSIVE EDGE PRESERVATION for thin lines
    var best_sample = vec4<f32>(0.0);
    var best_lum = 0.0;
    var worst_lum = 999.0;

    let input_base = output_coord * 2;
    for (var dy = 0; dy <= 1; dy++) {{
        for (var dx = 0; dx <= 1; dx++) {{
            let coord = clamp(
                input_base + vec2<i32>(dx, dy),
                vec2<i32>(0),
                vec2<i32>(input_size) - vec2<i32>(1)
            );
            let sample = textureLoad(input_texture, coord, 0);
            let lum = dot(sample.rgb, vec3<f32>(0.299, 0.587, 0.114));

            if (lum > best_lum) {{
                best_sample = unpremultiply_alpha(sample);
                best_lum = lum;
            }}
            worst_lum = min(worst_lum, lum);
        }}
    }}

    // Calculate contrast in the 2x2 region
    let local_contrast = best_lum - worst_lum;

    // Blend strategy: smooth areas use Kaiser, high contrast preserves brightest
    var result: vec4<f32>;
    if (local_contrast < 0.1) {{
        result = kaiser_result;
    }} else if (local_contrast < 0.3) {{
        let blend = (local_contrast - 0.1) / 0.2;
        result = mix(kaiser_result, best_sample, blend * 0.7);
    }} else {{
        result = mix(kaiser_result, best_sample, 0.85);
    }}

    result = premultiply_alpha(result);

    textureStore(output_texture, output_coord, result);
}}
"#
        ))
    }
}

/// Tile information for mipmap generation
pub struct TileInfo {
    pub pixel_offset: [u32; 2],  // Position in atlas at mip 0
    pub size: [u32; 2],          // Size at mip 0
    pub texture_type: u32,       // TextureType as u32
    pub layer_index: u32,        // Which layer this tile is in
}

pub async fn generate_mipmaps(
    gpu: &AwsmRendererWebGpu,
    texture: &web_sys::GpuTexture,
    tiles: Vec<TileInfo>,
    gutter: u32,
    array_layers: u32,
    is_array: bool,
    mip_levels: u32,
) -> Result<()> {
    use crate::buffers::{BufferDescriptor, BufferUsage};

    if tiles.is_empty() || mip_levels < 2 {
        return Ok(());
    }

    // Get tile-aware mipmap pipeline
    let MipmapPipeline {
        compute_pipeline: mipmap_pipeline,
        bind_group_layout: mipmap_bind_group_layout,
    } = get_tile_aware_mipmap_pipeline(gpu, texture.format(), is_array).await?;

    let command_encoder = gpu.create_command_encoder(Some("Generate Tile-Aware Mipmaps"));

    let view_dimension = if is_array {
        TextureViewDimension::N2dArray
    } else {
        TextureViewDimension::N2d
    };

    // Process each mip level
    for mip_level in 1..mip_levels {
        // Create texture views for source (mip_level - 1) and destination (mip_level)
        let mut src_view_descriptor = TextureViewDescriptor::new(Some("Tile Mip Source View"))
            .with_base_mip_level(mip_level - 1)
            .with_dimension(view_dimension)
            .with_mip_level_count(1);
        if is_array {
            src_view_descriptor = src_view_descriptor.with_array_layer_count(array_layers);
        }
        let src_view = texture
            .create_view_with_descriptor(&src_view_descriptor.into())
            .map_err(AwsmCoreError::create_texture_view)?;

        let mut dst_view_descriptor = TextureViewDescriptor::new(Some("Tile Mip Dest View"))
            .with_base_mip_level(mip_level)
            .with_dimension(view_dimension)
            .with_mip_level_count(1);
        if is_array {
            dst_view_descriptor = dst_view_descriptor.with_array_layer_count(array_layers);
        }
        let dst_view = texture
            .create_view_with_descriptor(&dst_view_descriptor.into())
            .map_err(AwsmCoreError::create_texture_view)?;

        // Process each tile
        for tile in &tiles {
            // Calculate tile bounds at this mip level
            let src_mip_scale = 1 << (mip_level - 1);
            let src_interior_min = [
                (tile.pixel_offset[0] / src_mip_scale) as i32,
                (tile.pixel_offset[1] / src_mip_scale) as i32,
            ];
            let src_interior_max = [
                ((tile.pixel_offset[0] + tile.size[0]) / src_mip_scale) as i32,
                ((tile.pixel_offset[1] + tile.size[1]) / src_mip_scale) as i32,
            ];

            // Create uniform buffer with tile parameters
            // Layout: vec2<i32> srcInteriorMin, vec2<i32> srcInteriorMax, i32 gutter, u32 textureType, [i32 layer for arrays]
            let params_data: Vec<i32> = if is_array {
                vec![
                    src_interior_min[0],
                    src_interior_min[1],
                    src_interior_max[0],
                    src_interior_max[1],
                    gutter as i32,
                    tile.texture_type as i32,
                    tile.layer_index as i32,
                    0, // padding for alignment
                ]
            } else {
                vec![
                    src_interior_min[0],
                    src_interior_min[1],
                    src_interior_max[0],
                    src_interior_max[1],
                    gutter as i32,
                    tile.texture_type as i32,
                    0, // padding
                    0, // padding
                ]
            };

            let params_buffer = gpu.create_buffer(
                &BufferDescriptor::new(
                    (params_data.len() * 4) as u64,
                    BufferUsage::new().with_uniform().with_copy_dst(),
                    Some("Tile Mipmap Params"),
                )
                .into(),
            )?;

            gpu.write_buffer_i32(&params_buffer, 0, &params_data);

            // Create bind group for this tile
            let tile_bind_group = gpu.create_bind_group(
                &BindGroupDescriptor::new(
                    &mipmap_bind_group_layout,
                    Some("Tile Mipmap Bind Group"),
                    vec![
                        BindGroupEntry::new(0, BindGroupResource::TextureView(Cow::Borrowed(&src_view))),
                        BindGroupEntry::new(1, BindGroupResource::TextureView(Cow::Borrowed(&dst_view))),
                        BindGroupEntry::new(2, BindGroupResource::Buffer(Cow::Owned(params_buffer))),
                    ],
                )
                .into(),
            );

            // Compute workgroup dispatch size for this tile's destination rect
            let dst_mip_scale = 1 << mip_level;
            let child_interior_min = [
                tile.pixel_offset[0] / dst_mip_scale,
                tile.pixel_offset[1] / dst_mip_scale,
            ];
            let child_interior_max = [
                (tile.pixel_offset[0] + tile.size[0] + dst_mip_scale - 1) / dst_mip_scale,
                (tile.pixel_offset[1] + tile.size[1] + dst_mip_scale - 1) / dst_mip_scale,
            ];
            let dst_rect_min = [
                child_interior_min[0].saturating_sub(gutter),
                child_interior_min[1].saturating_sub(gutter),
            ];
            let dst_rect_max = [
                child_interior_max[0] + gutter,
                child_interior_max[1] + gutter,
            ];
            let dispatch_width = (dst_rect_max[0] - dst_rect_min[0]).max(1);
            let dispatch_height = (dst_rect_max[1] - dst_rect_min[1]).max(1);

            let workgroup_size_x = (dispatch_width as u32).div_ceil(8);
            let workgroup_size_y = (dispatch_height as u32).div_ceil(8);

            // Dispatch compute shader for this tile
            let tile_pass = command_encoder.begin_compute_pass(Some(
                &ComputePassDescriptor::new(Some("Tile Mipmap Pass")).into(),
            ));
            tile_pass.set_pipeline(&mipmap_pipeline);
            tile_pass.set_bind_group(0, &tile_bind_group, None)?;
            tile_pass.dispatch_workgroups(workgroup_size_x, Some(workgroup_size_y), None);
            tile_pass.end();
        }
    }

    // Submit all commands
    let command_buffer = command_encoder.finish();
    gpu.submit_commands(&command_buffer);

    Ok(())
}

async fn get_tile_aware_mipmap_pipeline(
    gpu: &AwsmRendererWebGpu,
    format: TextureFormat,
    is_array: bool,
) -> Result<MipmapPipeline> {
    let key = LookupKey {
        texture_format: format!("{format:?}_tile_aware"),
        is_array,
    };

    if let Some(pipeline) =
        MIPMAP_PIPELINE.with(|pipeline_cell| pipeline_cell.borrow().get(&key).cloned())
    {
        return Ok(pipeline);
    }

    let shader_source = tile_aware_mipmap_shader_source(format.clone(), is_array)?;
    let shader_module = gpu.compile_shader(
        &ShaderModuleDescriptor::new(&shader_source, Some("Tile-Aware Mipmap Shader")).into(),
    );

    shader_module.validate_shader().await?;

    let compute = ProgrammableStage::new(&shader_module, None);

    let view_dimension = if is_array {
        TextureViewDimension::N2dArray
    } else {
        TextureViewDimension::N2d
    };

    let bind_group_layout = gpu.create_bind_group_layout(
        &BindGroupLayoutDescriptor::new(Some("Tile-Aware Mipmap Bind Group Layout"))
            .with_entries(vec![
                // Binding 0: Source texture (previous mip level)
                BindGroupLayoutEntry::new(
                    0,
                    BindGroupLayoutResource::Texture(
                        TextureBindingLayout::new()
                            .with_sample_type(TextureSampleType::Float)
                            .with_view_dimension(view_dimension)
                            .with_multisampled(false),
                    ),
                )
                .with_visibility_compute(),
                // Binding 1: Destination texture (current mip level - storage)
                BindGroupLayoutEntry::new(
                    1,
                    BindGroupLayoutResource::StorageTexture(
                        StorageTextureBindingLayout::new(format)
                            .with_view_dimension(view_dimension)
                            .with_access(StorageTextureAccess::WriteOnly),
                    ),
                )
                .with_visibility_compute(),
                // Binding 2: Uniform buffer with tile parameters
                BindGroupLayoutEntry::new(
                    2,
                    BindGroupLayoutResource::Buffer(crate::bind_groups::BufferBindingLayout::new())
                )
                .with_visibility_compute(),
            ])
            .into(),
    )?;

    let layout = gpu.create_pipeline_layout(
        &PipelineLayoutDescriptor::new(
            Some("Tile-Aware Mipmap Pipeline Layout"),
            vec![bind_group_layout.clone()],
        )
        .into(),
    );
    let layout = PipelineLayoutKind::Custom(&layout);

    let pipeline_descriptor = ComputePipelineDescriptor::new(
        compute,
        layout.clone(),
        Some("Tile-Aware Mipmap Pipeline"),
    );

    let pipeline = gpu
        .create_compute_pipeline(&pipeline_descriptor.into())
        .await?;

    MIPMAP_PIPELINE.with(|pipeline_cell| {
        let pipeline = MipmapPipeline {
            compute_pipeline: pipeline,
            bind_group_layout,
        };
        pipeline_cell.borrow_mut().insert(key, pipeline.clone());
        Ok(pipeline)
    })
}

async fn get_mipmap_pipeline(
    gpu: &AwsmRendererWebGpu,
    format: TextureFormat,
    is_array: bool,
) -> Result<MipmapPipeline> {
    let key = LookupKey {
        texture_format: format!("{format:?}"),
        is_array,
    };

    if let Some(pipeline) =
        MIPMAP_PIPELINE.with(|pipeline_cell| pipeline_cell.borrow().get(&key).cloned())
    {
        return Ok(pipeline);
    }

    let shader_source = mipmap_shader_source(format.clone(), is_array)?;
    let shader_module = gpu
        .compile_shader(&ShaderModuleDescriptor::new(&shader_source, Some("Mipmap Shader")).into());

    shader_module.validate_shader().await?;

    let compute = ProgrammableStage::new(&shader_module, None);

    let view_dimension = if is_array {
        TextureViewDimension::N2dArray
    } else {
        TextureViewDimension::N2d
    };

    let bind_group_layout = gpu.create_bind_group_layout(
        &BindGroupLayoutDescriptor::new(Some("Mipmap Bind Group Layout"))
            .with_entries(vec![
                // Binding 0: Input texture (previous mip level)
                BindGroupLayoutEntry::new(
                    0,
                    BindGroupLayoutResource::Texture(
                        TextureBindingLayout::new()
                            .with_sample_type(TextureSampleType::Float)
                            .with_view_dimension(view_dimension)
                            .with_multisampled(false),
                    ),
                )
                .with_visibility_compute(),
                // Binding 1: Edge map texture (same resolution as input)
                BindGroupLayoutEntry::new(
                    1,
                    BindGroupLayoutResource::Texture(
                        TextureBindingLayout::new()
                            .with_sample_type(TextureSampleType::Float)
                            .with_view_dimension(view_dimension)
                            .with_multisampled(false),
                    ),
                )
                .with_visibility_compute(),
                // Binding 2: Output texture (current mip level)
                BindGroupLayoutEntry::new(
                    2,
                    BindGroupLayoutResource::StorageTexture(
                        StorageTextureBindingLayout::new(format)
                            .with_view_dimension(view_dimension)
                            .with_access(StorageTextureAccess::WriteOnly),
                    ),
                )
                .with_visibility_compute(),
            ])
            .into(),
    )?;

    let layout = gpu.create_pipeline_layout(
        &PipelineLayoutDescriptor::new(
            Some("Mipmap Pipeline Layout"),
            vec![bind_group_layout.clone()],
        )
        .into(),
    );
    let layout = PipelineLayoutKind::Custom(&layout);

    let pipeline_descriptor =
        ComputePipelineDescriptor::new(compute, layout.clone(), Some("Mipmap Pipeline"));

    // UGH - move the whole thing out of the closure... let async infect everything... look at earlier async comment
    let pipeline = gpu
        .create_compute_pipeline(&pipeline_descriptor.into())
        .await?;

    MIPMAP_PIPELINE.with(|pipeline_cell| {
        let pipeline = MipmapPipeline {
            compute_pipeline: pipeline,
            bind_group_layout,
        };
        pipeline_cell.borrow_mut().insert(key, pipeline.clone());
        Ok(pipeline)
    })
}

async fn get_edge_detection_pipeline(
    gpu: &AwsmRendererWebGpu,
    format: TextureFormat,
    is_array: bool,
) -> Result<EdgeDetectionPipeline> {
    let key = LookupKey {
        texture_format: format!("{format:?}"),
        is_array,
    };

    if let Some(pipeline) =
        EDGE_DETECTION_PIPELINE.with(|pipeline_cell| pipeline_cell.borrow().get(&key).cloned())
    {
        return Ok(pipeline);
    }

    let shader_source = edge_detection_shader_source(format.clone(), is_array)?;
    let shader_module = gpu.compile_shader(
        &ShaderModuleDescriptor::new(&shader_source, Some("Edge Detection Shader")).into(),
    );

    shader_module.validate_shader().await?;

    let compute = ProgrammableStage::new(&shader_module, None);

    let view_dimension = if is_array {
        TextureViewDimension::N2dArray
    } else {
        TextureViewDimension::N2d
    };

    let bind_group_layout = gpu.create_bind_group_layout(
        &BindGroupLayoutDescriptor::new(Some("Edge Detection Bind Group Layout"))
            .with_entries(vec![
                // Binding 0: Input texture
                BindGroupLayoutEntry::new(
                    0,
                    BindGroupLayoutResource::Texture(
                        TextureBindingLayout::new()
                            .with_sample_type(TextureSampleType::Float)
                            .with_view_dimension(view_dimension)
                            .with_multisampled(false),
                    ),
                )
                .with_visibility_compute(),
                // Binding 1: Edge map output
                BindGroupLayoutEntry::new(
                    1,
                    BindGroupLayoutResource::StorageTexture(
                        StorageTextureBindingLayout::new(format)
                            .with_view_dimension(view_dimension)
                            .with_access(StorageTextureAccess::WriteOnly),
                    ),
                )
                .with_visibility_compute(),
            ])
            .into(),
    )?;

    let layout = gpu.create_pipeline_layout(
        &PipelineLayoutDescriptor::new(
            Some("Edge Detection Pipeline Layout"),
            vec![bind_group_layout.clone()],
        )
        .into(),
    );
    let layout = PipelineLayoutKind::Custom(&layout);

    let pipeline_descriptor =
        ComputePipelineDescriptor::new(compute, layout.clone(), Some("Edge Detection Pipeline"));

    let pipeline = gpu
        .create_compute_pipeline(&pipeline_descriptor.into())
        .await?;

    EDGE_DETECTION_PIPELINE.with(|pipeline_cell| {
        let pipeline = EdgeDetectionPipeline {
            compute_pipeline: pipeline,
            bind_group_layout,
        };
        pipeline_cell.borrow_mut().insert(key, pipeline.clone());
        Ok(pipeline)
    })
}

pub fn calculate_mipmap_levels(width: u32, height: u32) -> u32 {
    ((width.max(height) as f32).log2().floor() as u32) + 1
}

pub fn get_mipmap_size_for_level(base_width: u32, base_height: u32, mip_level: u32) -> (u32, u32) {
    let width = (base_width >> mip_level).max(1);
    let height = (base_height >> mip_level).max(1);
    (width, height)
}
